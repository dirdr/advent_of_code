use std::fmt::{Display, Write};

use crate::helper_lib::{answer::Answer, solution::Solution};

pub struct Day12;

impl Solution for Day12 {
    fn part_a(&self, input: &[String]) -> Answer {
        let parsed = parse(input);
        parsed.count_arrangements().into()
    }

    fn part_b(&self, input: &[String]) -> Answer {
        todo!()
    }
}

struct Parsed {
    rows: Vec<Row>,
}

impl Parsed {
    pub fn count_arrangements(&self) -> usize {
        fn dfs(row: &Row, pos: usize, group_index: usize, group_len: usize) -> usize {
            let temp = row
                .conditions
                .iter()
                .cloned()
                .map(|t| char::from(t))
                .collect::<Vec<_>>();
            println!("{:?}", temp);
            println!(
                "current group index : {}, current group len : {}, current position : {}, expected  group len {}",
                group_index, group_len, pos, row.group_sizes[group_index]
            );
            println!("");

            let mut arrangements = 0;

            if pos == row.conditions.len() {
                if row.group_sizes.len() == group_index {
                    arrangements = 1;
                } else {
                    arrangements = 0;
                };
            } else if row.conditions[pos] == &SpringCondition::Broken {
                arrangements = dfs(row, pos + 1, group_index, group_len + 1)
            } else if row.conditions[pos] == &SpringCondition::Working {
                if group_index < row.group_sizes.len() && group_len == row.group_sizes[group_index]
                {
                    // closing the block
                    arrangements = dfs(row, pos + 1, group_index + 1, 0);
                } else if group_len == 0 {
                    // multiple working..
                    arrangements = dfs(row, pos + 1, group_index, 0);
                }
            } else if row.conditions[pos] == SpringCondition::Unknown {
            }

            match row.conditions[pos] {
                SpringCondition::Working => {}
                SpringCondition::Unknown => {
                    // continue with broken spring
                    let mut new_row = row.clone();
                    new_row.conditions[pos] = SpringCondition::Broken;
                    arrangements += dfs(&new_row, pos + 1, group_index, group_len + 1);

                    // finished the block, closing
                    if group_index < row.group_sizes.len()
                        && group_len == row.group_sizes[group_index]
                    {
                        let mut new_row = row.clone();
                        new_row.conditions[pos] = SpringCondition::Working;
                        arrangements += dfs(&new_row, pos + 1, group_index + 1, 0);
                    } else if group_len == 0 {
                        arrangements += dfs(&new_row, pos + 1, group_index, 0);
                    }
                }
            };
            arrangements
        }
        let mut count = 0;
        for row in self.rows.iter() {
            let arrangements = dfs(row, 0, 0, 0);
            println!("count : {}", arrangements);
            println!("");
            count += arrangements;
        }
        count
    }
}

fn parse(input: &[String]) -> Parsed {
    let mut rows = vec![];
    for line in input {
        let (conditions, group_sized) = line.split_once(' ').unwrap();
        let group_sizes = group_sized
            .split(',')
            .map(|d| d.parse::<usize>().unwrap())
            .collect::<Vec<_>>();
        let conditions = conditions
            .chars()
            .map(|c| SpringCondition::from(c))
            .collect::<Vec<_>>();
        rows.push(Row {
            conditions,
            group_sizes,
        })
    }
    Parsed { rows }
}

#[derive(Clone)]
pub struct Row {
    conditions: Vec<SpringCondition>,
    group_sizes: Vec<usize>,
}

#[derive(Clone, PartialEq)]
pub enum SpringCondition {
    Broken,
    Working,
    Unknown,
}

impl Display for SpringCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SpringCondition::Broken => f.write_char('#'),
            SpringCondition::Working => f.write_char('.'),
            SpringCondition::Unknown => f.write_char('?'),
        }
    }
}

impl From<SpringCondition> for char {
    fn from(value: SpringCondition) -> Self {
        match value {
            SpringCondition::Broken => '#',
            SpringCondition::Working => '.',
            SpringCondition::Unknown => '?',
        }
    }
}

impl From<char> for SpringCondition {
    fn from(value: char) -> Self {
        match value {
            '.' => SpringCondition::Working,
            '#' => SpringCondition::Broken,
            '?' => SpringCondition::Unknown,
            _ => unreachable!(),
        }
    }
}

#[cfg(test)]
mod test {
    use crate::helper_lib::{self, answer::Answer, input, solution::Solution};

    use super::Day12;

    #[test]
    pub fn test_a() {
        let input =
            input::read_file(&format!("{}day_12_test.txt", helper_lib::FILES_PREFIX)).unwrap();
        let answer = Day12.part_a(&input);
        assert_eq!(<i32 as Into<Answer>>::into(21), answer);
    }

    pub fn test_b() {
        let input =
            input::read_file(&format!("{}day_12_test.txt", helper_lib::FILES_PREFIX)).unwrap();
        let answer = Day12.part_b(&input);
        assert_eq!(<i32 as Into<Answer>>::into(0), answer);
    }
}
